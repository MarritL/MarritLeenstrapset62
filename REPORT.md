# FINAL REPORT
Final Project App for Minor Programming at the Universitiy of Amsterdam

## Introduction
Vegetariano! is a mobile application helping users in the early stage of vegetarianism. It supplies them daily with new recipes. As well it helps keep users committed to their new diet by keeping track of the user's runstreak and total vegetarian days. With this is calculates how many animals are saved and how many CO2-emision is avoided by the user. Users can furthermore relate to the Vegetariano! community and check how many people ate vegetarian at a day, as well as how many animal kills and CO2-emission is avoided by the community as a whole.

## Screenshot
<img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/Home.jpg' width="200" height="400">

## Technical Design
The app supports four main functionalities:
1) Manage user account
2) Keep track whether user ate vegetarian at given day
3) Scoreboard user and community as a whole
4) Supply user with daily recipes

All four functionalities will now be described separately, together with the related code. After that the database design will be discussed.

### 1. Manage user account
To be able to save user data (e.g. how many days he followed the vegetarian diet), every user needs to have an account on the Vegetariano! app. Managing of the user account is done using FireBase Authentication. Supported actions are: registration, sign in, forgot password, change email adress, change display name, change password, log out and unsubscribe. Screenshots of these actions can be found below.

<img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/Signin.jpg' width="200" height="400"> <img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/Register.jpg' width="200" height="400"> <img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/Reset.jpg' width="200" height="400"> <img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/Settings.jpg' width="200" height="400">

The following diagram describes the architecture of the user management functionality:

<img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/ManageUsers2.JPG' width="700" height="350">

#### SignInActivity
The user first arrives at the SignInActivity, which is the launch screen. There he can choose several options: 1) sign in via de sign in button, 2) register by clicking at the 'I don't have an account yet' text, or 3) reset the password by clicking at the 'Oops... I forgot my password' text. All have a their own onClickListeners. When choosing the second or the third option, the user will go to the respective activities, which are childActivities of the SignInActivity. This is handy, because the user can now use up-navigation if he decides that he wants to go back to the sign in screen. When the user choses the first option his email and password will be checked by the firebase authentication service. If the login fails, the user will get a focus-text 'the password or email is incorrect'. If the login succeeds the prepareData function will be called. This function will initiate instances of the recipeLab singleton and communityLab singleton and make sure the onLaunch value in the database will be set to true. This to make sure the homepage is displayed well. The reason why the data is initiated here will be described in more detail in the paragraphs about the functionalities 3 (Scoreboard of user and community as a whole) and 4 (Supply user with daily recipes). If all this is done, the user will be taken through the SpashActivity to the MainActivity. The SplashActivity is needed to make sure all data needed in the MainActivity is actually loaded.

#### RegisterActivity
The RegisterActivity is fairly basic form, where the user has to fill in his emailadress, displayname and password. The display name is optional. When the user does not choose a display name the emailadress before the '@' will be used as displayname. This can later be changed in the SettingsFragment. When the user has filled the whole form, he will click the register-button which triggers the registerOnClick class, which in turn calls the attemptRegister() function. In this function the emailadress and password are validated by three functions: isEmailValid(), isPasswordValid() and isPasswordSame(). These functions make sure that the email contains a '@', the password is at least 6 characters long and the password and the repeated password are the same (i.e. the user did not make typos). If everything is alright, the register() function will be called. In this function the FireBase authentication service is used to create a useraccount and the createData function will be called upon succesful registration. The createData() function, creates a User object with the FireBase UID, the email and the displayname and all other variables set to 0. This User Object will be added to the FireBase Database. Lastly recipes will be downloaded from the server through the RecipesHelper Callback and these will be saved in the database as well. Since this is more relevant to the 4th functionality 'Supply user with daily recipes', this will be described in more detail in that section. If the user is registrated he will go back to SignInActivity

#### ForgotPasswordActivity
The ForgetPasswordActivity is another simple form. The user can provide his emailadress and when clicked on the button the sendEmailOnClick listener will be triggered. This in turn triggers the attemptSendEmail() function. In this function the emailadress is again validated with RegisterActivity's isEmailValid() function. If the user gave an emailadress with an '@', the sendEmail() function is called. Herein a passwordreset email is send to the emailadress. By following the instructions in the email, the user can reset his password. The user will be taken back to the SignInActivity.

#### MainActivity
After the user signed in, he will go through the SplashActivity to the MainActivity, as described in the paragraph 'SignInActivity'. The MainActvity contains a bottomNavigation, through which the user can directly navigate to 4 fragments. The HomeFragment, the UserFragment, the CommunityFragment and the SettingsFragment. For the 'user account management' functionality only the SettingsFragment is important. The MainActivity and other Fragments will therefore be discussed later.

#### SettingsFragment
The SettingsFragment displays 5 clickable TextViews, representing the following actions: change email address, change display name, change password, logout and unsubscribe. Listeners are attached to the TextViews. The change email address, change password and logout TextViews share a listener, in which an if-else statement directs the change email adress and change password to respectively the ChangeEmailFragment and ChangePasswordFragment. These fragments are discussed later. When logout is clicked the Firebase signout() method is called and the SignInActivity is started. For the change display name and unsubscribe actions dialogs are opened. This because a whole new fragment was not needed, since the required actions are rather small. The change display name dialog shows an EditText in which the user can fill in his new display name. When clicking the OK-button, the changeDisplayName() function is called in which the displayname is saved in the FireBase Database. When the user leaves the field empty, again the part of the emailadress before the '@' is used as display name. The unsubscribe dialog shows a warning, explaining the user that unsubscribing is irreversible. If he still decides to delete the account, the deleteUser() function is called. In this function the user is signed out, his data is deleted from the database and then the account is deleted with the FireBase delete() method. This order is important, because once the account is deleted the database cannot be accessed anymore and therefor deleting from the database after deleting the account will lead to errors. As well when the user is not signed out before deleting the database, the onDataChange methods will still be called, while there is no data in the database anymore. This will lead to errors as well. Both the change display name and unsubscribe dialogs have cancel buttons, pressing these buttons will close the dialog without further action.

#### ChangeEmailFragment
The ChangeEmailFragment is displayed in the MainActivity container, but only accessible via the SettingsFragment. Therefor the navigation is still accessible while in the ChangeEmailFragment. The ChangeEmailFragment works the same as the ForgotPasswordActivity. It contains a simple form in which the user can fill in his new email adress. Upon clicking the button, the attemptChangeEmail() function is called in which the emailadress is validated. If the emailadress is valid, the changeEmail() function will handle the actual change with the FireBase updateEmail() method. The user will be notified that he has to sign in with the new emailadress from that moment on. The email adress will be updated in the FireBase authentication and the FireBase database. As well a securitymail will be send to the old emailadress, notifying the user that the emailadress for this app was changed. By following the instructions in the email, he can revert this action. When the user is done, he will be taken back to the SettingsFragment.

#### ChangePasswordFragment
The ChangePasswordFragment works the same as the ChangeEmailFragment. It is displayed in the MainActivity container and accessed via the SettingsFragment. The user can fill in his new password and repeat that. When the change-button is clicked, the attemptChangePassword() function will be called to validate the password. If the password is valid (checked by the functions: isPasswordValid() and isPasswordSame() in RegisterActivity), the changePassword() function will be called. This will change the password in FireBase Authentication by the FireBase updatePassword() method. A security-email will again be send to the user's emailadress. By following the instruction in the email, he can submit this action. When the user is done, he will be taken back to the SettingsFragment.

### 2. Keep track whether user ate vegetarian at given day
One of the most important functionalities of the Vegetariano! app is keeping track of the vegetarian days of the users. The user is self responsible for the counting, in the sense that he has to say whether he did or did not eat vegetarian every day. This is then saved in the database. Since it is so important that he user does this every day, a reminder in the form of a notification is send to the user daily. If however, he did not anwer this question before 3 o'clock at night, this will be registered as a NO. 

The following diagram describes the architecture of the 'keep track whether user ate vegetarian at given day' functionality:

<img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/KeepTrack.JPG' width="700" height="370">

#### HomeFragment
The HomeFragment is very important for the 'keep track whether user ate vegetarian at given day' functionality, since it is the screen where the user can actually let the app know whether he ate vegetarian or not. First the User object is sent from the MainActivity to the HomeFragment. At the top of the screen the 'did you eat vegetarian' question is displayed with two buttons, respectively 'YES' and 'NO' (see very first Screenshot at the introduction paragraph). At least... when the user did not answer that question yet. This is checked with the clickedToday-getter from the User class. 
When the user clicks one of the two buttons, the todayVegetarianClickListener will be triggered. In the todayVegetarianClickListener YES and NO answers are separated. If the user clicked YES (i.e. he ate vegetarian that day) the values for 'clickedToday', 'daysVegetarian', 'runStreak', co2Avoided' and 'animalsSaved' will be updated in the database. clickedToday will be set to true, daysVegetarian and runStreak will be plussed with 1, co2Avoided with 1.5 and animalsSaved with 0.2. The daily gain for co2Avoided and animalsSaved are explained in the info screen in the userFragment. If the user however, clicked NO (i.e. he did not eat vegetarian) only the 'clickedToday' and 'runStreak' will be updated. ClickedToday is set to 'true' and the runStreak will be set to 0. Furthermore, the question and buttons will be hidden after a buttonclick and a message stating that the user did or did not eat vegetarian will be displayed.

#### MainActivity
The first time the MainActivity is launched the setRecurringAlarm() function for two daily alarms will be called. The first alarm is triggered daily around (i.e. inexact repeating) 19.00 o'clock and received by the AlarmReceiver class. The second alarm is triggered daily around 3.10 at night and received by the MyNightJobs class. Once the recurring alarms are set, a boolean 'mOnLaunchDone' is set to 'true'. This value is saved in the sharedPreferences. Every time onCreate is called, the sharedPreferences are restored and therefor the setRecurringAlarm() function will not be called again. The sharedPreferences are chosen to save the mOnLaunchDone value, because when a hypothetical reboot would turn off the alarms, the sharedPreferences would be deleted as well. Therefore, the setRecurringAlarm() function will be triggered again after a reboot and the alarms will be set again. The other functions of MainActivity are not important for the 'keep track whether user ate vegetarian at given day' functionality and will be therefor discussed in other paragraphs.

#### AlarmReceiver
The AlarmReceiver receives an alarm daily at 19.00 o'clock. In the AlarmReceiver class a notification is build. This notification is a reminder for the user that he has to answer the 'did you eat vegetarian' question in the Vegetariano! app. Upon clicking the notification, the SignInActivity is opened. After signing in, the MainActivity is opened with the HomeFragment in which the question is displayed. 19.00 o'clock has been chosen as trigger time, because it is assumed that the user by then knows whether he ate vegetarian that day or not. 

<img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/Notification.jpg' width="220" height="280">

#### MyNightJobs
The second alarm is triggered daily around 3.10 at night and received by the MyNightJobs class. The MyNightJobs class has two functions: checking if the user answered the question and download new recipes from the server. The second function will be discussed in the paragraph about the 4th functionality 'Supply user with daily recipes'. When the alarm is received by the MyNightJobs class the updateRunstreak() function will be triggered. In this function a FireBase singleValueEventListener is triggered to read the userdata from the database and save it in the User object. One value is in particular important for the 'keep track whether user ate vegetarian at given day' functionality, namely the 'clickedToday' value. Logically, if a user answered the question (i.e. clicked YES or NO) the user.getClickedToday function (getter from the User class) will return true, if not it will return false. If the user did not answer the question, his runstreak will be set to 0 in the database and other values do not change, since it is considered as a NO answer. If he indeed did answer the question, the user values are already handled in the database when he clicked YES or NO. The clickedToday value will be set to false again in the database, so that the user can answer the question again on the day to come. 

### 3. Scoreboard user and community as a whole
The third main functionality is displaying a scoreboard to the user. In this scoreboard he can see how many days he followed a vegetarian diet (both in a row and as a whole) and how much savings of animal lives and CO2 emissions this is yielding. Furthermore he can see the scoreboard for the whole community in which the values of all users are summed. The functionality of registration of the vegetarian days is already explained in the paragraph about the 2th functionality 'Keep track whether user ate vegetarian at given day'. This paragraph regards only the displaying of the scoreboards. Examples of the user and community scoreboards are displayed below.

<img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/User.jpg' width="200" height="400"> <img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/Community.jpg' width="200" height="400">

The following diagram describes the architecture of the 'Scoreboard user and community as a whole' functionality:

<img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/Scoreboard.JPG' width="700" height="370">

#### MainActivity
The main activity takes care of reading the User values from the database. It does so in the readFromDatabase() function which is called in the activities onCreate(). The readFromDatabase creates a FireBase valueEventListener, which is called once when created and again
whenever data in the database is updated. Inside the valueEventListeners onDataChange(), an updateUser() function is called. This function creates a User object with the data from the database. This object will therefore be renewed every time a value in the database changes. Inside this function as well the first 'tab' (homeFragement) in the bottomnavigation is selected, if the getOnLaunch() (getter from the User class) will return true. In this way, when the activity is created for the first time, the user won't see a white screen. The updateUser() function has been chosen as place to initiate the first tab, because the homeFragment needs the userData. Once the homeFragment is selected the boolean 'onLaunch' is set to false in the database. In this way, with when navigating away from the MainActivity and returning, the HomeFragment won't be selected automatically anymore. When one of homeFragment or userFragment is selected in the bottomNavigation, the User object will be send inside a bundle as an argument to the Fragment. In this way, the Fragments always have the latest userdata.

#### UserFragment
The UserFragment does nothing more then use the getters from the User class on the User Object that it got with the argument in the Fragment transaction, to display the user's values in a scoreboard. Since the runStreak works as an important motivator to keep the user committed to the vegetarian diet (i.e. if he reaches a high runStreak, he doesn't want to return to 0 by skipping the diet one day), the runStreak is highlighted in a more prominent place. All the other values are displayed in line below. It has been chosen to display the total animals saved in 'chicken', because the meat of 1 chicken happens to be on average 1kg (average slaughter weight / 2. Because the meat composes ca. half of the animal's slaughter weight (CBS, 2016)). Therefor every kg of meat not eaten, saves one chicken. Since the average meat consumption of a Dutch person is 76.8kg per year (CBS, 2016), the daily meat consumption is assumed to be 76.8/365 = 0.2kg. Therefore, every day the user saves 0.2 chicken and in 5 days this adds up to 1 chicken. The CO2 emission avoided is displayed in kg and a review of 14 articles revealed that a vegetarian diet avoids the emission of 540kg CO2-equivalent yearly (Hallström, Carlsson-Kanyama and Börjesson, 2014). Daily this is 540/365 = ca. 1.5 kg. Therefor every vegetarian day the CO2 emission avoided will be plussed with 1.5kg. These calculations are explained to the user in a dialog when he clickes the info-button, through the onInfoClickListener and showInfoDialog() function. Sources: Hallström, E., Carlsson-Kanyama, A., and Börjesson, P. (2015). Environmental impact of dietary change: a systematic review. Journal of Cleaner Production, 91, 1-11. and https://opendata.cbs.nl/statline/#/CBS/nl/dataset/7123slac/table?ts=1525770095591.

#### SignInActivity and CommunityLab
The display of the community data works a little different. Since there is always only one community, a singleton has been used to represent the community. The singleton is called the CommunityLab and initiated when on sign in, in the prepareData() function via getInstance(). If upon sign in there is not yet an instance of the communityLab (i.e. first sign in) the constructor CommunityLab() is called and the instance is created. The prepareData() function in the SignInActivity furthermore calls the fillCommunityData() function inside the CommunityLab. The fillCommunityData creates a FireBase onDataChange() ValueEventListener in which all users are passed by in a for-loop. In this way the values off all users can be summed in the respective community values. Once these summed values are created a Community Object is created or updated with the updateCommunity() function if there was a Community Object already. Other activities or fragments can get this object with the getCommunity() function.

#### SplashActivity
The splashActivity does nothing more than delaying the opening of the MainActivity from the SignInActivity with 1500 milliseconds (i.e. 1.5 second). This is needed because the fillCommunityData function works asynchronously. Therefor when the SignInActivity calls this function, it will right away proceed with the other functions and eventually go to the MainActivity. Without the SplashActivity it can be that fillCommunityData is not done yet when the getCommunity() function is called. This would then return a null pointer Error, because the Community object would not have been created yet. The same counts for the RecipeLab singleton functions which will be described in the paragraph about the 4th functionality 'Supply user with daily recipes'. Experimentation with the delay gave good results for 1.5 seconds, shorter caused sometimes null pointer errors, longer starts to be annoying.

#### CommunityFragment
The communityFragment uses the CommunityLab to display the community data in the scoreboard. First it recalls the instance of the communityLab, after which it calls communityLab's the getCommunity() function. As soon as the Community Object is present in the communityFragment it can use the Community class getters to display the 'total days eaten vegetarian', 'total animals saved (chicken)', 'total CO2 emission avoided (kg)', 'total people eating vegetarian today' and 'total participants'. As described before, this are just sums of the individual user's values.

### 4. Supply user with daily recipes
The 4th main functionality of the app is the most extensive one. The goal of this fourth functionality is to supply the user every day with 10 new recipes, so that the user can get inspiration for his meals and learns how to cook vegetarian. The recipes are daily requested from the Yummly API and are displayed in the HomeFragment. When the user clickes on one of the recipes, a new Yummly data request is performed as to give the user more details on the recipe in the RecipeFragment. If the user decides he wants to cook this meal, clicking on the 'get directions' button will lead to the source website with detailed prep directions. Examples of the displayed recipes and recipe details are shown below.

<img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/Home.jpg' width="200" height="400"> <img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/Recipe.jpg' width="200" height="400">

The architecture of the 'supply user with daily recipes' functionality looks like this:

<img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/DailyRecipes.JPG' width="700" height="370">

#### RegisterActivity 
When the user registers in the RegisterActivity the first recipes are downloaded in the createData() function, so that the user will see recipes on the HomeFragment right away. This is handled by the RecipesHelper through a callback. The exact downloading procedure will therefore be discussed in the RecipesHelper paragraph. Upon receiving the callback, with hopefully the recipes (i.e. gotRecipes() and not gotError()), the RecipeLab singleton is initiated with the RecipeLab.getInstance() function. After this RecipesLab's saveToDatabase() and fillRecipeArray() will be called. How this works exactly is described in the RecipeLab paragraph. However, it is important to note that these methods are called to make sure the recipes are actually present in the ArrayList when the RecipeLab.getRecipes() function is called in the HomeFragment, to prevent null pointer errors.

#### MyNightJobs
MyNightJobs is another class that which requests recipes from the Yummly API through the RecipesHelper callback interface. This works the same as in the RegisterActivity: upon receiving the callback the instance of the RecipeLab is created and the new recipes are saved in the database through the RecipeLab.saveToDataBase() method. Next the RecipeLab.fillRecipeArray() method will be called. In the paragraph about the 2th functionality 'Keep track whether user ate vegetarian at given day', is already explained that MyNightJobs is a broadcast receiver that receives a daily alarm at approximately 3.10 AM. The recipes are downloaded at night, so that the user sees new recipes when he opens the app in the morning. Furthermore, since many people charge the phone at night, the changes that the downloading of the recipes drains the battery are smaller. If the download does not succeed (for example because the user does not have internet connection), the old recipes will be displayed the next day.

#### RecipesHelper
The RecipesHelper is responsible for the actual downloading from the recipes from the Yummly API. To construct the request it uses the Volley library with the APIs search recipes GET request. To make sure that actually different recipes will be downloaded every day (or at least reasonably sure), an allowedIngredients[] parameter is used. In the assets a list of ingredients is saved. The getIngredientList() and getRandomIngredient() functions are used to pick a random ingredient from this list. This ingredient is used as the allowedIngredients parameter. Furthermore the allowedDiet[] parameter is used to make sure the recipes are actually vegetarian. When the RecipesHelper gets the response from the server (Volley's onResponse), the JSONobject is cast to new Recipe Objects. At this moment the recipes contain only an id, name, source name, rating and small image URL together with the required Yummly data (URL, text and logo). The recipe details will only be downloaded from the server if the user actually wants to see them. This is handled in the RecipesDetailHelper. 

#### RecipeLab
The first time the RecipeLab is initiated, (i.e. probably in the RegisterActivity, if the user opens the app on one phone only), the constructor RecipeLab() is called. This creates an empty arrayList and the FireBase database- and FireBase user- references. The RecipeLab has several functions, from which the first is saveToDatabase(). This function saves the recipes as a String to the database. This method is a remnant of an earlier method when the recipes where saved in the sharedPreferences. When given more time, it would have been nicer to save the recipes individually as Recipe objects to the database. However, saving the recipes as a String works fine when you cast them to Array again when reading from the database. This is done in the fillRecipeArray() function that is called by the RegisterActivity after saving the recipes to the database. The fillRecipeArray() function calls Firebase's onDataChange() ValueEventListener to read from the database. When receiving the data, the castToArray() function is called so that the recipes are saved in an ArrayList of Recipe Objects. The Activities or Fragments can now call the getRecipes() function, to retrieve the ArrayList with the 10 recipes. When a specific recipe is needed, the getRecipe() function is called, with the recipe id as input. This function iterates through the ArrayList until he finds the recipe with the specified id.

#### SignInActivity
When the user signs in, the prepareData() function will be called. In the 3th paragraph about the 'Scoreboard user and community as a whole' functionality. It has been already described that the CommunityLab will be initiated here, combined with the fillCommunityData() function, because then the data will be for sure available in the MainActivity and its fragments (with a little help of the SplashActivity). The same is true for the RecipeLab. In the prepareData() function, the RecipeLab.getInstance() and RecipeLab.fillRecipeArray() will be called, so that the recipe arrayList will be available when the HomeFragment call RecipeLab.getRecipes().

#### MainActivity
The MainActivity does nothing with the recipe data, the fragments it hosts however do.

#### HomeFragment
The HomeFragment is displayed in the MainActivity's container and is the place where the 10 daily recipes are displayed in a nice gridView. First the RecipeLab is initiated and the RecipeLab.getRecipes() function is called. The gridViewAdapter then makes sure that the recipes are nicely displayed. Furthermore the use of the Yummly API requires the display of the Yummly logo, link and search text with the data. This is therefore displayed in the HomeFragment as well. Clicking on the Yummly logo will call the goToSourceOnClick Listener in which the Yummly website will be opened. When one of the Recipes is clicked the MyRecipeClickedListener will be triggered. This class will lead to the user to the RecipeFragment, with the Fragment transaction the Recipe is send along as an argument. 

#### GridViewAdapter
The GridViewAdapter takes care of the displaying of the recipes in a nice grid. Every gridItem will display one recipe with its picture, name and sourcename. The source name is a requirement of the Yummly API. The picture handling is done by the Picasso library. When one of the recipes in the GridView is clicked (in the HomeFragment) the getItem() function will be called, so that the onClickListener knows which recipe was actually clicked.

#### RecipeFragment
The RecipeFragment receives the recipe from the HomeFragment and is displayed in the container of the MainActivity as well. The bottomNavigation can therefore be still used, however, the RecipeFragment can be only accessed via de HomeFragment by clicking on one of the recipes. When the user does this, the RecipeFragment replaces the HomeFragment and receives the recipe clicked with this transaction as an argument. The RecipeLab calls than the RecipeLab getInstance() method together with the getRecipe(id), to get the recipe details known so far. However, to be able to show the recipe in more detail, this details first have to be downloaded from the server. The RecipeFragment is therefor connected to the RecipeDetailHelper by a Callback method, much like the RegisterActivity and MyNightJobs class with the RecipeHelper. The downloading details will be described in the RecipeDetailHelper paragraph. Once the recipeDetails are received (i.e. gotRecipeDetails the recipe is displayed with the extra details in the UI. The Picasso library is again used to display the recipe image and a simple arrayAdapter is used to display the ingredients in a list. Furthermore a 'GET DIRECTIONS' button is displayed. When the user clicks this button the source's website will be opened, so that the user can read the cooking directions. 

#### RecipeDetailHelper
The RecipeDetailHelper works mostly the same as the RecipeHelper. It again is responsible for downloading the recipe details from the Yummly API and it uses the Volley library to construct the request. However this time the Yummly Get Recipe GET request is used instead of the Search Recipes request. This request uses the recipes id, that is downloaded in the RecipesHelper and saved in the Recipe Object. When the request is succesful, the JSONObject is casted to the Recipe object again. To merge the new details with the recipe data we got already, the RecipeLab is initiated and the RecipeLab.getRecipe(id) function is called. When all values are set, the recipe is with the callback sent to the RecipeFragment.

### Database
For this project the FireBase database was used. When starting this project only a user child in the database was foreseen. However, also a recipe child was added. The database design looks as follows:

<img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/DatabaseReal.JPG' width="400" height="400">

The recipe child contains a {User-uid} with the associated recipes in a key:value pair. In this way the recipes are connected to the user. As described before, the recipes are saved as a string. It would have been nicer to save the recipes as objects; however, this choice was a result of an earlier idea to save the recipes in the shared preferences. The User child is better structured, with every user saved under this own Uid, with the associated values as key:value pairs. However, the amount of properties per user is quite large and not all values are real properties. For example I would have preferred to save onLaunch in the app itself. However, saving in sharedPreferences was leading to errors, so I moved this value to the database as well. 

## Comparison with DESIGN DOCUMENT
At first sight the app looks like I planned at the start of this project. It performs the same four main functionalities and the UI design the screenshot of especially the HeadSpace app looks familiar. The design of the HomeFragment changed quite a bit, because I decided to display 10 recipes in steadof one. Compare:

<img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/Headspace.jpg' width="200" height="400"> <img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/User.jpg' width="200" height="400"> <img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/Yummly.jpg' width="200" height="400"> <img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/Home.jpg' width="200" height="400">

However, at the project was far larger than I expected when I planned it. I was thinking to use that app for the Native App studio project, which was supposed to be around two weeks. Okay, I decided on the go to show 10 recipes in the homeFragment because 1 recipe does not give that much inspiration and therefor I needed a whole new flow for the RecipeDetail, with another Fragment and downloading Helper class. Still even when considering this extra detail, it was far more work to construct this app then I expected. 

Firstly, I underestimated the architecture of the app. I was thinking to use one SignInActivity, one MainActivity with three Fragments and one SettingsActivity. For the displaying of the Recipes I wanted to use an AsynchTask (class) and a HTTPRequestHelper (class) like in the to-listen-list (pset3) of Native App studio. Furthermore I wanted to make a User class and save data in the FireBase database. This would sum up to 3 activities, 3 fragments and 3 classes defined outside the activities or fragments. However, now that the project is finished it contains 5 activities, 7 fragments, 2 singletons and 8 other classes defined outside the activities or fragments.

I soon realized that the user management needed much more than only a SignInActivity, with most importantly the RegisterActivity. Furthermore, I wanted to add account management functionality, because I never like apps that don't send you a new password when you have forgotten or that don't allow you to change your password, emailadress or let you unsubscribe. Since for all these small functions new forms are needed, new activities or fragments where the easiest way to accomplish this. Some very small functions could be handled in dialogs instead. Besides the user management also the data management needed a larger architecture than I thought about beforehand. I created singletons to handle the community and recipes, as well as separate classes for them. Other two functionalities that I added where the notification and the nightjobs in the setarate alarms. This was needed because they needed to perform on different times. The nightjobs were necessary to reset the runstreak for the new day and because I wanted to supply the user with new recipes automatically. Another option would have been a refresh button for the recipes. In that way the user could have chosen himself when he wanted new recipes. I didn't choose that, because I really wanted it to be daily recipe inspiration. 

Secondly, I encountered some hard-to-overcome bugs that took me a lot of time. Mostly the bottom navigation with the fragments did not work well together with the savedInstanceState that I used. Since it was the first time I worked with fragments, I didn't take this in consideration when planning this project. This was the main reasons I moved some extra values to the database. Before I found the right solution for this problem however, I moved around my classes quite a bit and even crated a singleton for the user class. This turned out not to work well, because I wanted to be able to have more accounts on one phone. So more instances where needed. Furthermore, the onDataChange method from FireBase was now called in the singleton, so this did not result in change of data on the display until you loaded the fragment again. Therefor I had to delete the singleton again and change the structure back. I tried to do this whit version control, but this broke the whole app and I had to 'copy' everything to a new project.

## Ideal world
In an ideal world with much more time, I would have restructured the database. To be exact the recipe child. I would probably not save the recipes in the database all together, but just download new recipes every time the user opened the app. However, this would require a way for the user to save some recipes, because otherwise he might see something he likes and then open the app before dinner to check the recipe and it would be gone.













