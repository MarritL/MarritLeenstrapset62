# FINAL REPORT
Final Project App for Minor Programming at the Universtiy of Amsterdam

## Introduction
Vegetariano! is a mobile application helping users in the early stage of vegetarianism. It supplies them daily with new recipes. As well it helps keep users commited to their new diet by keeping track of the user's runstreak and total vegetarian days. With this is calculates how many animals are saved and how many CO2-emision is avoided by the user. Users can furthermore relate to the Vegetariano! community and check how many people ate vegetarian at a day, as well as how many animal kills and CO2-emission is avoided by the community as a whole.

## Screenshot
<img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/Home.jpg' width="200" height="400">

## Technical Design
The app supports four main functionalities:
1) Mangage user account
2) Keep track whether user ate vegetarian at given day
3) Scoreboard user and community as a whole
4) Supply user with daily recipes

All four functionalities will now be described seperately, together with the related code.

### 1. Manage user account
To be able to save userdata (e.g. how many days he followed the vegetarian diet), every user needs to have an account on the Vegetariano! app. Managing of the user account is done using FireBase Authentication. Supported actions are: registration, sign in, forgot password, change email adress, change display name, change password, log out and unsubscribe. Screenshots of these actions can be found below.

<img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/Signin.jpg' width="200" height="400"> <img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/Register.jpg' width="200" height="400"> <img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/Reset.jpg' width="200" height="400"> <img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/Settings.jpg' width="200" height="400">

The following diagram describes the architecture of the user management functionality:

<img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/ManageUsers2.JPG' width="700" height="350">

#### SignInActivity
The user first arrives at the SignInActivity, which is the launch screen. There he can choose several options: 1) sign in via de sign in button, 2) register by clicking at the 'I don't have an account yet' text, or 3) reset the password by clicking at the 'Oops... I forgot my password' text. All have a their own onClickListeners. When choosing the second or the third option, the user will go to the respective activities, which are childActivities of the SignInActivity. This is handy, because the user can now use up-navigation if he decides that he wants to go back to the sign in screen. When the user choses the first option his email and password will be checked by the firebase authentication service. If the login fails the user will get a focus-text 'the password or email is incorrect'. If the login succeeds the prepareData function will be called. This function will initiate instances of the recipeLab singleton and communityLab singleton and make sure the onLaunch value in the database will be set to true. This to make sure the homepage is displayed well. The reason why the data is initiated here will be described in more detail in the paragraphs about the functionalities 3 (Scoreboard of user and community as a whole) and 4 (Supply user with daily recipes). If all this is done, the user will be taken through the SpashActivity to the MainActivity. The SplashActivity is needed to make sure all data needed in the MainActivity is actually loaded.

#### RegisterActivity
The RegistrerActivity is fairly basic form, where the user has to fill in his emailadress, displayname and password. The display name is optional. When the user does not choose a display name the emailadress before the '@' will be used as displayname. This can later be changed in the SettingsFragment. When the user has filled the whole form he will click the register-button which triggers the registerOnClick class, which in turn calls the attemptRegister() function. In this funcion the emailadress and password are validated by three functions: isEmailValid(), isPasswordValid() and isPasswordSame(). These functions make sure that the email contains a '@', the password is at least 6 characters long and the password and the repeated password are the same (i.e. the user did not make typos). If everything is alright, the register() function will be called. In this function the FireBase authentication service is used to create a useraccount and the createData function will be called upon succesful registration. The createData() function, creates a User object with the FireBase UID, the email and the displayname and all other variables set to 0. This User Object will be added to the FireBase Database. Lastly recipes will be downloaded from the server through the RecipesHelper Callback and these will be saved in the database as well. Since this is more relevant to the 4th functionality 'Supply user with daily recipes', this will be described in more detail in that section. If the user is registrated he will go back to SignInActivity

#### ForgotPasswordActivity
The ForgetPasswordActivity is another simple form. The user can provide his emailadress and when clicked on the button the sendEmailOnClick listener will be triggered. This in turn triggers the attemptSendEmail() function. In this function the emailadress is again validated with RegisterActivty's isEmailValid() function. If the user gave an emailadress with an '@', the sendEmail() function is called. Herein a passwordreset email is send to the emailadress. By following the instructions in the email the user can reset his password. The user will be taken back to the SignInActivity.

#### MainActivity
After the user signed in, he will go through the SplashActivity to the MainActivity, as described in the paragraph 'SignInActivity'. The MainActvity contains a bottomNavigation, through which the user can directly navigate to 4 fragments. The HomeFragment, the UserFragment, the CommunityFragment and the SettingsFragment. For the 'user account managment' functionality only the SettingsFragment is important. The MainActivity and other Fragments will therefor be discussed later.

#### SettingsFragment
The SettingsFragment displays 5 clickable TextViews, representing the following actiosn: change email address, change display name, change password, logout and unsubscribe. Listeners are attached to the TextViews. The change email address, change password and logout TextViews share a listener, in which a if-else statement directs the change email adress and change password to respectively the ChangeEmailFragment and ChangePasswordFragment. These fragments are discussed later. When logout is clicked the Firebase signout() method is called and the SignInActivity is started. For the change display name and unsubscribe actions dialogs are opened. This becuase a whole new fragment was not needed, since the required actions are rather small. The change display name dialog shows an EditText in which the user can fill in his new display name. When clicking the OK-button, the changeDisplayName() function is called in which the displayname is saved in the FireBase Database. When the user leaves the field empty, again the part of the emailadress before the '@' is used as display name. The unsubscribe dialog shows a warning, explaining the user that unsubscribing is irreversable. If he still decides to delete the account, the deleteUser() fucntion is called. In this function the user is signed out, his data is deleted from the database and then the account is deleted with the FireBase delete() method. This order is important, because once the account is deleted the database cannot be accessed anymore and therefor deleting from the database after deleting the account will lead to errors. As well when the user is not signed out before deleting the database, the onDataChange methods will still be called, while there is no data in the database anymore. This will lead to errors as well. Both the change display name and unsubscribe dialogs have cancel buttons, pressing these buttons will close the dialog without further action.

#### ChangeEmailFragment
The ChangeEmailFragment is displayed in the MainActivity container, but only accessable via the SettingsFragment. Therefor the navigation is still accessable while in the ChangeEmailFragment. The ChangeEmailFragment works the same as the ForgotPasswordActivity. It contains a simple form in which the user can fill in his new email adress. Uppon clicking the button, the attemptChangeEmail() function is called in which the emailadress is validated. If the emailadress is valid, the changeEmail() function will handel the actual change with the FireBase updateEmail() method. The user will be notified that he has to sign in with the new emailadress from that moment on. The email adress will be updated in the FireBase authentication and the FireBase database. As well a securitymail will be send to the old emailadress, notifying the user that the emailadress for this app was changed. By following the instructions in the email, he can revert this action. When the user is done, he will be taken back to the SettingsFragment.

#### ChangePasswordFragment
The ChangePasswordFragment works the same as the ChangeEmailFragment. It is displayed in the MainActivity container and accessed via the SettingsFragment. The user can fill in his new password and repeat that. When the change-button is clicked, the attemptChangePassword() function will be called to validate the password. If the password is valid (checked by the fuctions: isPasswordValid() and isPasswordSame() in RegisterActivity), the changePassword() function will be called. This will change the password in FireBase Authentication by the FireBase updatePassword() method. A securityemail will again be send to the user's emailadress. By following the instruction in the email, he can submit this action. When the user is done, he will be taken back to the SettingsFragment.

### 2. Keep track whether user ate vegetarian at given day
One of the most important functionalities of the Vegetariano! app is keeping track of the vegetarian days of the users. The user is self responsible for the counting, in the sense that he has to say whether he did or did not eat vegetarian every day. This is then saved in the database. Since it is so important that he user does this every day, a reminder in the form of a notification is send to the user daily. If however, he did not anwere this question before 3 o'clock at night, this will be registered as a NO. 

The following diagram describes the architecture of the 'keep track whether user ate vegetarian at given day' functionality:

<img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/KeepTrack.JPG' width="700" height="370">

#### HomeFragment
The homeFragment is very important for the 'keep track whether user ate vegetarian at given day' functionality, since it is the screen where the user can actually let the app know whether he ate vegetarian or not. First the User object is sent from the MainActivity to the HomeFragment. At the top of the screen the 'did you eat vegetarian' question is displayed with two buttons, respectively 'YES' and 'NO' (see very first ScreenShot at the introductin paragraph). At least... when the user did not answer that question yet. This is checked with the clickedToday-getter from the User class. 
When the user clicks one of the two buttons, the todayVegetarianClickListener will be triggered. In the todayVegetarianClickListener YES and NO answers are separated. If the userer cicked YES (i.e. he ate vegetarian that day) the values for 'clickedToday', 'daysVegetarian', 'runStreak', co2Avoided' and 'animalsSaved' will be updated in the database. clickedToday wil be set to true, daysVegetarian and runStreak will be plussed with 1, co2Avoided with 1.5 and animalsSaved with 0.2. The daily gain for co2Avoided and animalsSaved are explained in the infoscreen in the userFragment. If the user however, clicked NO (i.e. he did not eat vegetarian) only the 'clickedToday' and 'runStreak' will be updated. ClickedToday is set to 'true' and the runStreak will be set to 0. Furthermore, the question and buttons will be hided after a buttonclick and a message stating that the user did or did not eat vegetarian will be displayed.

#### MainActivity
The first time the MainActivity is launched the setRecurringAlarm() function for two daily alarms will be called. The first alarm is triggered daily around (i.e. inexact repeating) 19.00 o'clock and received by the AlarmReceiver class. The second alarm is triggerd daily arount 3.10 at night and received by the MyNightJobs class. Once the recurrin alarms are set, a boolean 'mOnLaunchDone' is set to 'true'. This value is saved in the sharedPreferences. Every time onCreate is called, the sharedPreferences are restored and therefor the setRecurringAlarm() function will not be called again. The sharedPreferences are chosen to save the mOnLaunchDone value, because when a hypothetical rebooth would turn off the alarms, the sharedPreferences would be deleted as well. Therefor, the setRecurringAlarm() function will be triggered again after a rebooth and the alarms will be set again. The other functions of MainActivity are not important for the 'keep track whether user ate vegetarian at given day' functionality and will be therefor discussed in other paragraphs.

#### AlarmReceiver
The AlarmReceiver receives an alarm daily at 19.00 o'clock. In the AlarmReceiver class a notification is build. This notification is a reminder for the user that he has to answer the 'did you eat vegetarian' question in the Vegetariano! app. Uppon clicking the notification, the SignInActivity is opened. After signing in, the MainActivity is opened with the HomeFragment in which the question is displayed. 19.00 o'clock has been chosen as triggertime, because it is assumed that the user by then knows whether he ate vegetarian that day or not. 

<img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/Notification.jpg' width="220" height="280">

#### MyNightJobs
The second alarm is triggered daily around 3.10 at night and received by the MyNightJobs class. The MyNightJobs class has two functions: checking if the user answered the question and download new recipes from the server. The second function will be discussed in the paragraph about the 4th functionality 'Supply user with daily recipes'. When the alarm is received by the MyNightJobs class the updateRunstreak() function will be triggered. In this function a FireBase singleValueEventListener is triggered to read the userdata from the database and save it in the User object. One value is in particular important for the 'keep track whether user ate vegetarian at given day' functionality, namely the 'clickedToday' value. Logically, if a user answered the question (i.e. clicked YES or NO) the user.getClickedToday function (getter from the User class) will return true, if not it will return false. If the user did not answer the question, his runstreak will be set to 0 in the database and other values do not change, since it is considered as a NO answer. If he indeed did answer the question, the user values are already handeled in the database when he clicked YES or NO. The clickedToday value will be set to false again in the database, so that the user can answer the question again on the day to come. 

### 3. Scoreboard user and community as a whole
The third main functionality is displaying a scoreboard to the user. In this scoreboard he can see how many days he followed a vegetarian diet (both in a row and as a whole) and how much savings of animal lives and CO2 emissions this is yielding. Furthermore he can see the scoreboard for the whole community in which the values of all users are summed. The functionality of registration of the vegetarian days is already explained in the paragraph about the 2th functionality 'Keep track whether user ate vegetarian at given day'. This paragraph regards only the displaying of the scoreboards. Examples of the user and community scoreboards are displayed below.

<img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/User.jpg' width="200" height="400"> <img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/Community.jpg' width="200" height="400">

The following diagram describes the architecture of the 'Scoreboard user and community as a whole' functionality:

<img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/Scoreboard.JPG' width="700" height="370">

#### MainActivity
The main activity takes care of reading the User values from the database. It does so in the readFromDatabase() function which is called in the activities onCreate(). The readFromDatabase creates a FireBase valueEventListener, which is called once when created and again
whenever data in the database is updated. Inside the valueEventListeners onDataChange(), an updateUser() function is called. This function creates a User object with the data from the database. This object will therefor be renewed every time a value in the database changes. Inside this function as well the first 'tab' (homeFragement) in the bottomnavigation is selected, if the getOnLaunch() (getter from the User class) will return true. In this way, when the activity is created for the first time, the user won't see a white screen. The updateUser() function has been chosen as place to inititate the first tab, because the homeFragment needs the userData. Once the homeFragment is selected the boolean 'onLaunch' is set to false in the database. In this way, with when navigating away from the MainActivity and returning, the homeFragment won't be selected automatically anymore. When one of homeFragment or userFragment is selected in the bottomNavigation, the User object will be send inside a bundle as an argument to the Fragment. In this way, the Fragments always have the latest userdata.

#### UserFragment
The UserFragment does nothing more then use the getters from the User class on the User Object that it got with the argument in the Fragment transaction, to display the user's values in a scoreboard. Since the runStreak works as an important motivater to keep the user commited to the vegetarian diet (i.e. if he reaches a high runStreak, he doesn't want to return to 0 by skipping the diet one day), the runStreak is highlighted in a more prominent place. All the other values are displayed in line below. It has been chosen to display the total animals saved in 'chicken', because the meat of 1 chicken happens to be on average 1kg (average slaughter weight / 2. Because the meat composes ca. half of the animals slaughter weight (CBS, 2016)). Therefor every kg of meat not eaten, saves one chicken. Since the average meat consumption of a Dutch person is 76.8kg per year (CBS, 2016), the daily meat consumption is assumed to be 76.8/365 = 0.2kg. Therefor, every day the user saves 0.2 chicken and in 5 days this adds up to 1 chicken. The CO2 emission avoided is displayed in kg and a review of 14 articles revieled that a vegetarian diet avoids the emission of 540kg CO2-equivalent yearly (Hallström, Carlsson-Kanyama and Börjesson, 2014). Daily this is 540/365 = ca. 1.5 kg. Therefor every vegetarian day the CO2 emission avoided will be plussed with 1.5kg. These calculations are explained to the user in a dialog when he clickes the info-button, through the onInfoClickListener and showInfoDialog() function. Sources: Hallström, E., Carlsson-Kanyama, A., and Börjesson, P. (2015). Environmental impact of dietary change: a systematic review. Journal of Cleaner Production, 91, 1-11. and https://opendata.cbs.nl/statline/#/CBS/nl/dataset/7123slac/table?ts=1525770095591.

#### SignInActivity and CommunityLab
The display of the community data works a little different. Since there is always only one community, a sigleton has been used to represent the this community. The singleton is called the Communitylab and initiated when on sign in, in the prepareData() fucntion via getInstance(). If uppon sign in there is not yet an instance of the communityLab (i.e. first sign in) the constructor CommunityLab() is called and the instance is created. The prepareData() function in the SignInActivity furthermore calles the fillCommunityData() function inside the CommunityLab. The fillCommunityData creates a FireBase onDataChange() ValueEventListener in which all users are passed by in a for-loop. In this way the values off all users can be summed in the respective community values. Once these summed values are created a Community Object is created or updated with the updateCommunity() function if there was a Community Object already. Other activities or fragments can get this object with the getCommunity() function.

#### SplashActivity
The splashActivity does nothing more then delaying the opening of the MainActivity from the SignInActivity with 1500 milliseconds (i.e. 1.5 second). This is needed because the fillCommunityData function works asynchronously. Therefor when the SignInActivity calls this function, it will right away proceed with the other functions and eventually go to the MainActivity. Without the SplashActivity it can be that fillCommunityData is not done yet when the getCommunity() function is called. This would then return a null pointer Error, becuase the Community object would not have been created yet. The same counts for the RecipeLab singleton functions which will be described in the paragraph about the 4th funcionality 'Supply user with daily recipes'. Experimentation with the delay gave good results for 1.5 seconds, shorter caused sometimes null pointer errors, longer starts to be annoying.

#### CommunityFragment
The communityFragment uses the CommunityLab to display the community data in the scoreboard. First it recalls the instance of the communityLab, after which it calls communityLab's the getCommunity() function. As soon as the Community Object is present in the communityFragment it can use the Community class getters to display the 'total days eaten vegetarian', 'total animals saved (chicken)', 'total CO2 emission avoided (kg)', 'total people eating vegetarian today' and 'total participants'. As described before, this are just sums of the individual users values.

### 4. Supply user with daily recipes
The 4th main functionality of the app is the most extensive one. The goal of this fourth functionality is to supply the user every day with 10 new recipes, so that the user can get inspiration for his meals and learns how to cook vegetarian. The recipes are daily requested from the Yummly API and are displayed in the HomeFragment. When the user clickes on one of the recipes, a new Yummly data request is performed as to give the user more details on the recipe in the RecipeFragment. If the user decides he wants to cook this meal, clicking on the 'get directions' button will lead to the source website with detailed prep directions. Examples of the displayed recipes and recipe details are shown below.

<img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/Home.jpg' width="200" height="400"> <img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/Recipe.jpg' width="200" height="400">

The architecture of the 'supply user with daily recipes' functionality looks like this:

<img src='https://github.com/MarritL/MarritLeenstrapset62/blob/master/docs/DailyRecipes.JPG' width="700" height="370">

#### RegisterActivity 
When the user registers in the RegistersActivity the first recipes are downloaded in the createData() function, so that the user will see recipes on the HomeFragment right away. This is handeled by the RecipesHelper through a callback. The exact downloading procedure will therefor be discussed in the RecipesHelper paragraph. Uppon receiving the callback, with hopefully the recipes (i.e. gotRecipes() and not gotError()), the RecipeLab sigleton is initiated with the RecipeLab.getInstance() function. After this RecipesLab's saveToDatabase() and fillRecipeArray() will be called. How this works exactly is decribed in the RecipeLab paragraph. However, it is important to not that this methods are called to make sure the recipes are actually present in the ArrayList when the RecipeLab.getRecipes() function is called in the HomeFragment, to prevent null pointer errors.

#### MyNightJobs
MyNightJobs is another class that which requests recipes from the Yummly API through the RecipesHelper callback interface. This works the same as in the RegisterActivity: uppon receiving the callback the instance of the RecipeLab is created and the new recipes are saved in the database through the RecipeLab.saveToDataBase() method. Next the RecipeLab.fillRecipeArray() method will be called. In the paragraph about the 2th functionality 'Keep track whether user ate vegetarian at given day', is already explained that MyNightJobs is a broadCast receiver that receivs a daily alarm at approximately 3.10 AM. The recipes are downloaded at night, so that the user sees new recipes when he opens the app in the morning. Furthermore, since many people charge the phone at night, the changes that the downloading of the recipes drains the battery are smaller. If the download does not succeed (for example because the user does not have internet connection), the old recipes will be displayed the next day.

#### RecipesHelper
The RecipesHelper is responsible for the actual downloading from the recipes from the Yummly API. To construct the request it uses the Volley library with the APIs search recipes GET request. To make sure that actually different recipes will be downloaded every day (or at least reasonabily sure), an allowedIngredients[] parameter is used. In the assets a list of ingredients is saved. The getIngredientList() and getRandomIngredient() functions are used to pick a random ingredient from this list. This ingredient is used as the allowedIngredients parameter. Furthermore the allowedDiet[] parameter is used to make sure the recipes are actually vegetarian. When the RecipesHelper gets the response from the server (Volley's onResponse), the JSONobject is cast to new Recipe Objects. At this moment the recipes contain only an id, name, source name, rating and small image url together with the requiered Yummly data (url, text and logo). The recipe details will only be downloaded from the server if the user actually wants to see them. This is handeled in the RecipesDetailHelper. 

#### RecipeLab
The first time the RecipeLab is initiated, (i.e. probably in the RegisterActivity, if the user opens the app on one phone only), the constructor RecipeLab() is called. This creates an empty arrayList and the FireBase database- and FireBase user- references. The RecipeLab has several functions, from which the first is saveToDatabase(). This function saves the recipes as a String to the database. This method is a remnant of an earlier method when the recipes where saved in the sharedPreferences. When given more time, it would have been nicer to save the recipes indiviually as Recipe objects to the database. However, saving the recipes as a String works fine when you cast them to Array again when reading from the database. This in done in the fillRecipeArray() function that is called by the RegisterActivity after saving the recipes to the database. The fillRecipeArray() function calls Firebase's onDataChange() ValueEventListener to read from the database. When receiving the data, the castToArray() function is called so that the recipes are saved in a ArrayList of Recipe Objects. The Activities or Fragements can now call the getRecipes() function, to retrieve the ArrayList with the 10 recipes. When a specific recipe is needed, the getRecipe() function is called, with the recipe id as input. This function iterates through the ArrayList untill he finds the recipe with the specified id.

#### SignInActivity
When the user signs in, the prepareData() function will be called. In the 3th paragraph about the 'Scoreboard user and community as a whole' functionality. It has been already described that the CommunityLab will be initiated here, combined with the fillCommunityData() function, because then the data will be for sure available in the MainActivity and it's fragments (with a little help of the SplashActivity). The same is true for the RecipeLab. In the prepareData() function, the RecipeLab.getInstance() and RecipeLab.fillRecipeArray() will be called, so that the recipe arrayList will be available when the HomeFragment call RecipeLab.getRecipes().

#### MainActivity
The MainActivity does nothing with the recipe data, the fragments it hosts however do.

#### HomeFragment
The HomeFragment is displayed in the MainActivity's container and is the place where the 10 daily recipes are displayed in a nice gridView. First the RecipeLab is initiated and the RecipeLab.getRecipes() function is called. The gridViewAdapter then makes sure that the recipes are nicely displayed. Furthermore the use of the Yummly API requires the display of the Yummly logo, link and search text with the data. This is therefor displayed in the HomeFragment as well. Clicking on the Yummly logo will call the goToSourceOnClick Listener in which the Yummly website will be opened. When one of the Recipes is clicked the MyRecipeClickedListener will be triggerd. This class will lead to the user to the RecipeFragment, with the Fragment transaction the Recipe is send along as an argument. 

#### GridViewAdapter
The GridViewAdapter takes care of the displaying of the recipes in a nice grid. Every gridItem will display one recipe with it's picture, name and sourcename. The source name is a requirment of the Yummly API. The picture handeling is done by the Picasso library. When one of the recipes in the GridView is clicked (in the HomeFragment) the getItem() function will be called, so that the onClickListener knows which recipe was actually clicked.

#### RecipeFragment
The RecipeFragment receives the recipe from the HomeFragment, and is displayed in the container of the MainActivity as well. The bottomNavigation can therefor be still used, however, the RecipeFragment can be only accesed via de HomeFragment by clicking on one of the recipes. When the user does this, the RecipeFragment replaces the HomeFragment and receives the recipe clicked with this transaction as an argument. The RecipeLab calls than the RecipeLab getInstance() method together with the getRecipe(id), to get the recipe details known so far. However, to be able to show the recipe in more detail, this details first have to be downloaded from the server. The RecipeFragment is therefor connected to the RecipeDetailHelper by a Callback method, much like the RegisterActivity and MyNightJobs class with the RecipeHelper. The downloading details will be described in the RecipeDetailHelper paragraph. Once the recipeDetails are received (i.e. gotRecipeDetails the recipe is displayed with the extra details in the UI. The picasso library is again used to display the recipeimage and a simple arrayAdapter is used to display the ingrediets in a list. Furthermore a 'GET DIRECTIONS' button is diplayed. When the user clicks this button a the source's website will be opened, so that the user can read the cooking directions. 

#### RecipeDetailHelper
The RecipeDetailHelper works mostly the same as the RecipeHelper. It again is responsible for downloading the recipe details from the Yummly API and it uses the Volley library to construct the request. However this time the Yummly Get Recipe GET request is used instead of the Search Recipes request. This request uses the recipes id, that is downloaded in the RecipesHelper and saved in the Recipe Object. When the request is succesful, the JSONObject is casted to the Recipe object again. To merge the new details with the recipe data we got already, the RecipeLab is initiated and the RecipeLab.getRecipe(id) function is called. When all values are set, the recipe is with the callback sent to the RecipeFragment.










